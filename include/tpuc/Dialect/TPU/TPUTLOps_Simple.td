//===-- TPUTLOps.td - TPU dialect operation definitions ------*- tablegen -*-===//
//
// Copyright 2019 The MLIR Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// =============================================================================
//
// Defines some operations of the GPU dialect.
//
//===----------------------------------------------------------------------===//

#ifndef TPU_TL_OPS
#define TPU_TL_OPS

include "tpuc/Dialect/TPU/TPUBase.td"
include "tpuc/Dialect/TPU/TPUInterface.td"

//===----------------------------------------------------------------------===//
// Quantization methods enum definitions.
//===----------------------------------------------------------------------===//

// Allowed quantization methods cases
def TPU_LM_LO_NONE    : StrEnumAttrCase<"NONE">;
def TPU_LM_LO_IWO     : StrEnumAttrCase<"IWO">;
def TPU_LM_LO_OWI     : StrEnumAttrCase<"OWI">;

def TPU_LMLayoutAttr : StrEnumAttr<
    "TpuLMLayoutType", "TL lmem layout enum", [
      TPU_LM_LO_NONE,  TPU_LM_LO_IWO,  TPU_LM_LO_OWI
    ]>;

// Allowed quantization methods cases
def TPU_LM_NONE : StrEnumAttrCase<"NONE">;
def TPU_LM_I    : StrEnumAttrCase<"I">;
def TPU_LM_O    : StrEnumAttrCase<"O">;

def TPU_LMOrderAttr : StrEnumAttr<
    "TpuLMOrderType", "TL lmem order enum", [
      TPU_LM_NONE,  TPU_LM_I,  TPU_LM_O
    ]>;


//===----------------------------------------------------------------------===//
// TL op definitions.
//===----------------------------------------------------------------------===//

def TPU_TL_LA_Conv2DOp : TPU_Op<"tl_la_conv_2d",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>]> {
  let summary = "TL Load All Convolution operator";

  let description = [{
    [IMPORTANT] : for INT8_MULTIPLIER quantized convolution only.
    Performs TL convolution operation on inputs memref, and output to output
      memref. The input/output/weight are still global memory tensors, so this
      operator has to handle loading input/weight and store output by itself.

    Inputs:
      `inputs[0]`  : required: the input memref.
      `inputs[1]`  : required: the filter memref.
      `inputs[2]`  : required: the perchannel memref.
  }];

  let arguments = (
    ins AnyTensor:$input,
    AnyTensor:$filter,
    AnyTensor:$pc_info,
    TPU_ConvParamAttr:$param,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    DefaultValuedAttr<BoolAttr, "false">:$do_leaky_relu,
    OptionalAttr<I8Attr>:$rshift_pos,
    OptionalAttr<I8Attr>:$m_i8_pos,
    OptionalAttr<I8Attr>:$rshift_neg,
    OptionalAttr<I8Attr>:$m_i8_neg,
    StrAttr:$name,
    OptionalAttr<BoolAttr>:$do_ic_alignment,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

def TPU_TL_LW_Conv2DOp : TPU_Op<"tl_lw_conv_2d",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>,
       DeclareOpInterfaceMethods<TpuTLSimpleOpCodegenInterface>] > {
  let summary = "TL Load Weight Convolution operator";

  let description = [{
    [IMPORTANT] : for INT8_MULTIPLIER quantized convolution only.
    Performs TL convolution operation on inputs memref, and output to output
      memref. The weight are still global memory tensors, so this operator has
      to handle loading weight by itself.

    Examples:
       %A = tpu.tl_load(%2) {gaddr = 0x60000000}: memref<?x?xf32, offset: 0, strides: [?, 1]>
       %B = tpu.tl_alloc() : memref<?x?xf32, offset: 0, strides: [?, 1]>
       tpu.tl_lw_conv_2d(%A, %B, %4, %5) { ... } : \
           (memref<1x64x56x56xi8, offset: 0x100, strides: [?, 1]>, \
            memref<1x256x56x56xi8, offset: 0x4000, strides: [?, 1]>, \
            tensor<256x64x3x3xi8>, tensor<256x9xi8>) -> tensor<1x256x56x56xf32>)

    Inputs:
      `inputs[0]`  : required: the input memref.
      `inputs[1]`  : required: the filter tensor.
      `inputs[2]`  : required: the per_channel_info tensor.
  }];

  let arguments = (
    ins AnyTensor:$input,
    AnyTensor:$filter,
    AnyTensor:$pc_info,
    TPU_ConvParamAttr:$param,
    TPU_LMLayoutAttr:$lm_layout,
    I32Attr:$la_input,
    I32Attr:$la_working,
    I32Attr:$la_output,
    BoolAttr:$tl_load_flag,
    BoolAttr:$tl_store_flag,
    OptionalAttr<BoolAttr>:$in_short_path,
    DefaultValuedAttr<BoolAttr, "false">:$do_leaky_relu,
    OptionalAttr<I8Attr>:$rshift_pos,
    OptionalAttr<I8Attr>:$m_i8_pos,
    OptionalAttr<I8Attr>:$rshift_neg,
    OptionalAttr<I8Attr>:$m_i8_neg,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    StrAttr:$name,
    OptionalAttr<BoolAttr>:$do_ic_alignment,
    OptionalAttr<I32Attr>:$tiled_oc_step,
    OptionalAttr<BoolAttr>:$compressed_weight,
    OptionalAttr<BoolAttr>:$load_compr_act,
    OptionalAttr<TPU_ActCmprParamAttr>:$load_compr_act_param,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

def TPU_TL_BroadcastMulOp : TPU_Op<"tl_broadcast_mul",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>,
       DeclareOpInterfaceMethods<TpuTLSimpleOpCodegenInterface>]> {
  let summary = "TL BroadcastMul operator";

  let description = [{
  }];

  let arguments = (
    ins AnyTensor:$input,
    AnyTensor:$filter,
    TPU_TensorOfOrNone<[I32,I16,I8]>:$pc_info,
    TPU_ConvParamAttr:$param,
    OptionalAttr<I8Attr>:$pt_rshift,
    TPU_LMLayoutAttr:$lm_layout,
    I32Attr:$la_input,
    I32Attr:$la_working,
    I32Attr:$la_output,
    BoolAttr:$tl_load_flag,
    BoolAttr:$tl_store_flag,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

class TPU_TL_EltwiseOp<string mnemonic, string opQuant, string opType> : TPU_Op<mnemonic,
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>,
       DeclareOpInterfaceMethods<TpuTLSimpleOpCodegenInterface>]> {
  let summary = "TL " # opQuant # " Eltwise " # opType # " operator.";

  let description = [{
  }];

  let arguments = (
    ins AnyTensor:$input,
    AnyTensor:$addend,
    I8Attr:$rshift,
    OptionalAttr<I32ArrayAttr>:$m_i8_inputs,
    OptionalAttr<I32Attr>:$m_i32_output,
    DefaultValuedAttr<BoolAttr, "false">:$do_relu,
    DefaultValuedAttr<BoolAttr, "false">:$do_early_stride,
    DefaultValuedAttr<I32Attr, "1">:$early_stride_h,
    DefaultValuedAttr<I32Attr, "1">:$early_stride_w,
    TPU_LMLayoutAttr:$lm_layout,
    I32Attr:$la_input,
    I32Attr:$la_working,
    I32Attr:$la_output,
    BoolAttr:$tl_load_flag,
    BoolAttr:$tl_store_flag,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

def TPU_TL_EltwiseAddOp : TPU_TL_EltwiseOp<"tl_eltwise_add", "Int8", "Add">;
def TPU_TL_EltwiseMulOp : TPU_TL_EltwiseOp<"tl_eltwise_mul", "Int8", "Mul">;

class TPU_TL_Pool2DOp<string mnemonic, string opQuant, string opType> : TPU_Op<mnemonic,
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>,
       DeclareOpInterfaceMethods<TpuTLSimpleOpCodegenInterface>]> {
  let summary = "TL " # opQuant # " Pool2D " # opType # " operator.";

  let description = [{
    Inputs:
      `input`          : required, the input1 activation memref.

    Attributes:
      `rshift`          : optional, rshift, an int8 value.
      `m_i8`            : optional, multiplier for output.
      `param`           : required, a PoolParam struct attributes, carrying
                          filter size, stride, padding, and do_relu.
      `region`          : required, the memory region to reside in, could be
                          one of `INPUT`, `OUTPUT`, `ACTIVATION` or `WEIGHT`.
                          (backend does not support `INPUT`, `OUTPUT` for now)
      `gaddr`           : optional, address in global memory, normally the
                          offset within the memory region.
      `buffer_reused`   : optional, whether buffer is reused.
      `name`            : required, name for comparing, or debug.
      `chipname`        : optional, chipname.

    Result:
      `output`          : result tensor.

    Interfaces or Traits:
      `NoSideEffect`
      `TpuOpCommonInterface`    : support common TPU TG Op interface.
      `TpuTGOpCodegenInterface` : support generate TPU instuctions.
  }];

  let arguments = (
    ins AnyTensor:$input,
    OptionalAttr<I8Attr>:$rshift,
    OptionalAttr<I8Attr>:$m_i8,
    TPU_PoolParamAttr:$param,
    TPU_LMLayoutAttr:$lm_layout,
    I32Attr:$la_input,
    I32Attr:$la_working,
    I32Attr:$la_output,
    BoolAttr:$tl_load_flag,
    BoolAttr:$tl_store_flag,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

def TPU_TL_PoolAvg2DOp : TPU_TL_Pool2DOp<"tl_pool_avg_2d", "Int8", "Avg">;


def TPU_TL_LutOp : TPU_Op<"tl_lut",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>,
       DeclareOpInterfaceMethods<TpuTGOpCodegenInterface>,
       DeclareOpInterfaceMethods<TpuTLSimpleOpCodegenInterface>]> {
  let summary = "TL " # opQuant # "lut operator.";

  let description = [{
    Inputs:
      `input`          : required, the variadic activation memref.
      `table`          : required, the lookup table

    Attributes:
      `region`          : required, the memory region to reside in, could be
                          one of `INPUT`, `OUTPUT`, `ACTIVATION` or `WEIGHT`.
                          (backend does not support `INPUT`, `OUTPUT` for now)
      `gaddr`           : optional, address in global memory, normally the
                          offset within the memory region.
      `name`            : required, name for comparing, or debug.
      `chipname`        : optional, chipname.

    Result:
      `output`          : result tensor.

    Interfaces or Traits:
      `NoSideEffect`
      `TpuOpCommonInterface`    : support common TPU TG Op interface.
      `TpuTGOpCodegenInterface` : support generate TPU instuctions.
  }];

  let arguments = (
    ins AnyTensor:$input,
    AnyTensor:$table,
    AnyTensor:$table_mantissa,
    TPU_LMLayoutAttr:$lm_layout,
    I32Attr:$la_input,
    I32Attr:$la_working,
    I32Attr:$la_output,
    BoolAttr:$tl_load_flag,
    BoolAttr:$tl_store_flag,
    DefaultValuedAttr<TPU_MemRegionAttr, "ACTIVATION">:$region,
    OptionalAttr<UI64Attr>:$gaddr,
    OptionalAttr<BoolAttr>:$buffer_reused,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

def TPU_TL_Fake_LoadOp : TPU_Op<"tl_fake_load",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>
       ]> {
  let summary = "TL Fake Load operator";

  let description = [{
  }];

  let arguments = (
    ins AnyTensor:$input,
    TPU_LMOrderAttr:$lm_order,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}


def TPU_TL_Fake_StoreOp : TPU_Op<"tl_fake_store",
      [NoSideEffect,
       DeclareOpInterfaceMethods<TpuOpCommonInterface>
      ]> {
  let summary = "TL Fake Store operator";

  let description = [{
  }];

  let arguments = (
    ins AnyTensor:$input,
    TPU_LMOrderAttr:$lm_order,
    StrAttr:$name,
    OptionalAttr<StrAttr>:$chipname
  );

  let results = (outs AnyTensor:$output);
}

#endif // TPU_TL_OPS
