#include "mlir/Dialect/TPU/TPUDialect.h"
#include "mlir/Dialect/TPU/Passes.h"
#include "mlir/Dialect/TPU/TPUOperationSupport.h"
#include "mlir/Dialect/TPU/TPUTensorSupport.h"
#include "mlir/Dialect/TPU/QuantizationArithmetic.h"
#include "mlir/Dialect/StandardOps/Ops.h"
#include "mlir/IR/BlockAndValueMapping.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/StandardTypes.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/IR/Matchers.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/Support/TensorFile.h"
#include "llvm/Support/raw_ostream.h"

#include <sstream>
#include <fstream>
#include <math.h>

#define DEBUG_TYPE "segment"

using namespace mlir;

static llvm::cl::OptionCategory clOptionsCategory("segment options");

static llvm::cl::opt<bool> clQuantConvPerChannel(
    "enable-quantization-in-tpu",
    llvm::cl::desc("Enable do quantization in tpu segment"),
    llvm::cl::init(false),
    llvm::cl::cat(clOptionsCategory));

namespace {

template<typename OpTy>
struct DefaultSplitPattern : public RewritePattern {
  DefaultSplitPattern(MLIRContext *context)
      : RewritePattern(OpTy::getOperationName(), 1, context) {}

  PatternMatchResult matchAndRewrite(Operation *op_inst,
      PatternRewriter &rewriter) const override {
    //auto *initBlock = rewriter.getInsertionBlock();
    //auto initPosition = rewriter.getInsertionPoint();
    //auto *endBlock = rewriter.splitBlock(initBlock, initPosition);
    auto orig_block = op_inst->getBlock();
    auto* tail_block = orig_block->splitBlock(op_inst);

    mlir::OpBuilder builder(op_inst);
    builder.setInsertionPointToEnd(orig_block);
    auto retOp = builder.create<tpu::TerminatorOp>(op_inst->getLoc());

    //tail_block->addArguments(retOp.getResult()->getType());
    //op_inst->getResult(0)->replaceAllUsesWith(retOp.getResult());

    return matchSuccess();
  }
};

class TpuSegmentPass : public FunctionPass<TpuSegmentPass> {
public:
  void runOnFunction() override {
    auto *context = &getContext();
    auto fn = getFunction();

    OwningRewritePatternList patterns;
    patterns.insert<
        DefaultSplitPattern<tpu::FullyConnectedOp>
        >(context);
    applyPatternsGreedily(fn, patterns);

#if 0
  // Start by splitting the block containing the 'loop.for' into two parts.
  // The part before will get the init code, the part after will be the end
  // point.
  auto *initBlock = rewriter.getInsertionBlock();
  auto initPosition = rewriter.getInsertionPoint();
  auto *endBlock = rewriter.splitBlock(initBlock, initPosition);
# endif

#if 0
    Builder builder(context);

    // Then, run blocks one by one.
    for (Block &bb : fn.getBlocks()) {
      auto tpuRegionOp = OpBuilder(&bb).create<tpu::LaunchTpuOp>(builder.getUnknownLoc());
      for (auto &op : bb) {
        llvm::errs() << op.getName() << "\n";
        if (auto retOp = cast<ReturnOp>(op)) {
          llvm::errs() << "Return Op \n";
          builder.inlineRegionBefore(tpuRegionOp.body(), &retOp);
        }
      }
    }
#endif

#if 0
    bool hasElseRegion = !op.elseRegion().empty();
    auto ifOp = rewriter.create<loop::IfOp>(loc, cond, hasElseRegion);
    rewriter.inlineRegionBefore(op.thenRegion(), &ifOp.thenRegion().back());
    ifOp.thenRegion().back().erase();
    if (hasElseRegion) {
      rewriter.inlineRegionBefore(op.elseRegion(), &ifOp.elseRegion().back());
      ifOp.elseRegion().back().erase();
    }
#endif
  }
};

} // namespace

std::unique_ptr<OpPassBase<FuncOp>> createTpuSegmentPass() {
  return std::make_unique<TpuSegmentPass>();
}

static PassRegistration<TpuSegmentPass>
    pass("tpu-segment",
         "Segment function into from TPU or CPU blocks");

